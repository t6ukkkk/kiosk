<!doctype html>
<html lang="et">
<head>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Elektri hind</title>
  <style>
    :root { color-scheme: dark; }
    html,body{
      margin:0;padding:0;
      font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial;
      background:#0b0b0c;color:#eaeaea;
    }
    header{
      position:sticky;top:0;z-index:10;
      background:#0b0b0c;border-bottom:1px solid #222;
      padding:10px 12px
    }
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pill{display:inline-block;padding:4px 10px;border-radius:999px;background:#16181a;border:1px solid #2a2d31;font-size:12px}
    .muted{opacity:.75;font-size:12px}
    .big{font-size:22px;font-weight:700}
    .grid{display:grid;grid-template-columns:repeat(4,minmax(140px,1fr));gap:10px;margin-top:10px}
    .card{background:#121416;border:1px solid #24282d;border-radius:14px;padding:10px}
    .k{opacity:.7;font-size:12px;margin-bottom:4px}
    .v{font-size:18px;font-weight:700}
    main{padding:10px 12px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .tag{font-size:12px;opacity:.8}
    .err{color:#ff6b6b}
    @media (max-width: 900px){
      .grid{grid-template-columns:repeat(2,minmax(140px,1fr));}
    }
  </style>
</head>
<body>

<header>
  <div class="row">
    <span class="pill">Macdronic → tabel</span>
    <span id="title" class="big">Laen…</span>
    <span id="updated" class="muted"></span>
    <span class="pill muted">Auto-refresh: <span id="refresh_s">60</span>s</span>
  </div>

  <div class="grid">
    <div class="card"><div class="k">Hetkel</div><div class="v"><span id="current" class="mono">—</span> <span class="tag">senti/kWh</span></div></div>
    <div class="card"><div class="k">Päeva keskmine</div><div class="v"><span id="avg" class="mono">—</span> <span class="tag">senti/kWh</span></div></div>
    <div class="card"><div class="k">Päeva min</div><div class="v"><span id="min" class="mono">—</span> <span class="tag">senti/kWh</span></div></div>
    <div class="card"><div class="k">Päeva maks</div><div class="v"><span id="max" class="mono">—</span> <span class="tag">senti/kWh</span></div></div>
  </div>
</header>

<main>
  <div id="error" class="err"></div>
  <div style="height:65vh;">
    <canvas id="priceChart"></canvas>
  </div>
</main>

<script>
const SRC = "https://cold-shape-2620.mihkel-pranstibel.workers.dev/";

let chart;
let currentBarIndex = -1;

// Store latest chart state so we can update highlight without re-fetching
let latest = {
  labels: [],
  data: [],
  tsList: []
};

// --- UI refresh config ---
const REFRESH_MS = 30 * 60 * 1000;      // fetch JSON every 60s
const HIGHLIGHT_MS = 15 * 1000;    // re-evaluate current hour every 15s

// show refresh seconds in header (your pill)
document.getElementById("refresh_s").textContent = String(Math.round(REFRESH_MS / 1000));

function fmt2(n){
  return (Number.isFinite(n) ? n.toFixed(2) : "—");
}

function sameLocalHour(tsSeconds, nowDate){
  const d = new Date(tsSeconds * 1000);
  return (
    d.getFullYear() === nowDate.getFullYear() &&
    d.getMonth() === nowDate.getMonth() &&
    d.getDate() === nowDate.getDate() &&
    d.getHours() === nowDate.getHours()
  );
}

function colorForValue(v){
  if (!Number.isFinite(v)) return "rgba(120,120,120,0.6)";
  if (v > 18) return "rgba(255, 90, 90, 0.85)";     // red
  if (v < 11) return "rgba(120, 255, 160, 0.85)";   // green
  return "rgba(255, 180, 80, 0.85)";                // orange
}

// Group 15-min points into hourly averages
function toHourlyAverages(timeline){
  const map = new Map(); // key -> {sum, count, ts}
  for (const t of timeline){
    const ts = Number(t.startTimestamp ?? t.timestamp);
    const price = Number(t.price ?? t.value);
    if (!Number.isFinite(ts) || !Number.isFinite(price)) continue;

    const d = new Date(ts * 1000);
    const key =
      d.getFullYear() + "-" +
      String(d.getMonth()+1).padStart(2,"0") + "-" +
      String(d.getDate()).padStart(2,"0") + " " +
      String(d.getHours()).padStart(2,"0");

    const cur = map.get(key) ?? { sum: 0, count: 0, ts: ts };
    cur.sum += price;
    cur.count += 1;
    if (ts < cur.ts) cur.ts = ts; // earliest timestamp for ordering
    map.set(key, cur);
  }

  const rows = [...map.entries()]
    .map(([key, v]) => ({ ts: v.ts, avg: v.sum / v.count }))
    .sort((a,b) => a.ts - b.ts);

  const labels = rows.map(r => {
    const d = new Date(r.ts * 1000);
    return String(d.getHours()).padStart(2,"0") + ":00"; // 24h
  });

  return {
    labels,
    data: rows.map(r => r.avg),
    tsList: rows.map(r => r.ts)
  };
}

// ---- Spotlight / glow column plugin (you already asked for this) ----
const glowCurrentBarPlugin = {
  id: 'glowCurrentBar',
  beforeDatasetsDraw(chart) {
    const idx = currentBarIndex;
    if (idx < 0) return;

    const meta = chart.getDatasetMeta(0);
    const el = meta?.data?.[idx];
    if (!el) return;

    const ctx = chart.ctx;
    const area = chart.chartArea;
    if (!area) return;

    const props = el.getProps(['x','width'], true);
    const x = props.x;
    const w = props.width;

    const padX = Math.max(8, w * 0.35);
    const left = x - (w / 2) - padX;
    const width = w + padX * 2;

    const top = area.top;
    const height = area.bottom - area.top;

    ctx.save();

    // outer glow
    ctx.shadowColor = 'rgba(255,255,255,0.65)';
    ctx.shadowBlur = 22;

    // spotlight column
    ctx.fillStyle = 'rgba(255,255,255,0.10)';
    ctx.fillRect(left, top, width, height);

    // border
    ctx.shadowBlur = 0;
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 2;
    ctx.strokeRect(left + 1, top + 1, width - 2, height - 2);

    ctx.restore();
  }
};

function recomputeCurrentIndexAndRestyle(){
  if (!chart || !latest.tsList.length) return;

  const now = new Date();
  const newIdx = latest.tsList.findIndex(ts => sameLocalHour(ts, now));

  // only update if changed (saves work)
  if (newIdx === currentBarIndex) return;

  currentBarIndex = newIdx;

  // restyle dataset (current bar brighter + white border)
  const ds = chart.data.datasets[0];

  ds.backgroundColor = latest.data.map((v, i) => {
    const c = colorForValue(v);
    if (i === currentBarIndex) return c.replace(/0\.85\)$/, "0.98)");
    return c;
  });

  ds.borderWidth = (ctx) => (ctx.dataIndex === currentBarIndex ? 2 : 0);
  ds.borderColor = (ctx) => (ctx.dataIndex === currentBarIndex ? "rgba(255,255,255,0.95)" : "rgba(0,0,0,0)");

  chart.update("none");
}

function drawChart(labels, data) {
  const ctx = document.getElementById("priceChart");
  if (chart) chart.destroy();

  chart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      datasets: [{
        data,
        backgroundColor: data.map((v, i) => {
          const c = colorForValue(v);
          if (i === currentBarIndex) return c.replace(/0\.85\)$/, "0.98)");
          return c;
        }),
        borderWidth: (ctx) => (ctx.dataIndex === currentBarIndex ? 2 : 0),
        borderColor: (ctx) => (ctx.dataIndex === currentBarIndex ? "rgba(255,255,255,0.95)" : "rgba(0,0,0,0)")
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      plugins: { legend: { display: false } },
      scales: {
        x: {
          ticks: {
            autoSkip: true,
            maxTicksLimit: 24,
            minRotation: 90,
            maxRotation: 90
          },
          grid: {
            display: true,
            color: 'rgba(255,255,255,0.1)',
            lineWidth: 1
          }
        },
        y: {
          beginAtZero: true,
          ticks: { stepSize: 5 },
          grid: {
            display: true,
            color: 'rgba(255,255,255,0.2)', // a bit brighter than before
            lineWidth: 1
          },
          title: { display: true, text: "senti/kWh" }
        }
      }
    },
    plugins: [glowCurrentBarPlugin]
  });
}

async function loadData() {
  const errorEl = document.getElementById("error");
  errorEl.textContent = "";

  // Force bypass any caching
  const url = SRC + (SRC.includes("?") ? "&" : "?") + "t=" + Date.now();

  const r = await fetch(url, { cache: "no-store" });
  if (!r.ok) throw new Error("HTTP " + r.status);

  const j = await r.json();

  // summary numbers
  document.getElementById("current").textContent = fmt2(j.currentPrice);
  document.getElementById("avg").textContent = fmt2(j.avg);
  document.getElementById("min").textContent = fmt2(j.min);
  document.getElementById("max").textContent = fmt2(j.max);

  if (j.chartTitle) document.getElementById("title").textContent = j.chartTitle;

  // show local “last updated (fetched)” time so you can verify it’s running
  const now = new Date();
  const hh = String(now.getHours()).padStart(2,"0");
  const mm = String(now.getMinutes()).padStart(2,"0");
  const ss = String(now.getSeconds()).padStart(2,"0");
  document.getElementById("updated").textContent = `• uuendatud (fetch) ${hh}:${mm}:${ss}`;

  const timeline = Array.isArray(j.timeline) ? j.timeline : [];
  const { labels, data, tsList } = toHourlyAverages(timeline);

  if (!labels.length || !data.length) {
    throw new Error("Graafiku andmeid ei leitud (timeline tühi või väljad ei klapi).");
  }

latest = { labels, data, tsList };

// compute current hour index from the NEW data
const nowDate = new Date();
currentBarIndex = tsList.findIndex(ts => sameLocalHour(ts, nowDate));

// ---- SUMMARY NUMBERS ----
// Avg = full-day (today 00:00 -> end of day)
// Min/Max = remaining day (current hour -> end of day)

const nowDate = new Date();
const todayY = nowDate.getFullYear();
const todayM = nowDate.getMonth();
const todayD = nowDate.getDate();

// indices that belong to TODAY (midnight..23:xx)
const todayIdx = [];
for (let i = 0; i < tsList.length; i++) {
  const d = new Date(tsList[i] * 1000);
  if (d.getFullYear() === todayY && d.getMonth() === todayM && d.getDate() === todayD) {
    todayIdx.push(i);
  }
}

// fallback if something odd
const idxToday = todayIdx.length ? todayIdx : tsList.map((_, i) => i);

// FULL-DAY avg
const valsFullDay = idxToday.map(i => data[i]).filter(Number.isFinite);
const avgV = valsFullDay.reduce((a,b)=>a+b,0) / (valsFullDay.length || 1);

// REMAINING-DAY min/max (from current hour onwards)
let startIdx = currentBarIndex;

// If the current hour bar isn't found (rare), approximate using "today indices at/after current hour"
if (startIdx < 0) {
  const h = nowDate.getHours();
  startIdx = idxToday.find(i => (new Date(tsList[i] * 1000)).getHours() >= h) ?? idxToday[0];
}

const idxRemaining = idxToday.filter(i => i >= startIdx);
const valsRemaining = idxRemaining.map(i => data[i]).filter(Number.isFinite);

const minV = Math.min(...valsRemaining);
const maxV = Math.max(...valsRemaining);

// CURRENT = highlighted bar (or first remaining bar)
const curIdx = (currentBarIndex >= 0 ? currentBarIndex : idxRemaining[0]);
const curV = Number.isFinite(data[curIdx]) ? data[curIdx] : NaN;

document.getElementById("current").textContent = fmt2(curV);
document.getElementById("avg").textContent = fmt2(avgV);
document.getElementById("min").textContent = fmt2(minV);
document.getElementById("max").textContent = fmt2(maxV);

drawChart(labels, data);

}

// ---- start everything ----
(async ()=>{
  try { await loadData(); }
  catch(e){ document.getElementById("error").textContent = "Viga: " + (e?.message ?? e); }
})();

// Fetch refresh (data window shifts / old hours drop off)
setInterval(async ()=>{
  try { await loadData(); }
  catch(e){ document.getElementById("error").textContent = "Viga: " + (e?.message ?? e); }
}, REFRESH_MS);

// Highlight refresh (moves to next hour even if data stays same)
setInterval(()=>{
  try { recomputeCurrentIndexAndRestyle(); } catch {}
}, HIGHLIGHT_MS);
</script>


</body>
</html>






